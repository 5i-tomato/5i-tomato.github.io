[{"content":"Hello, world!\n","date":"2020-03-17T00:00:00Z","image":"https://5i-tomato.github.io/p/hello-world/1_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://5i-tomato.github.io/p/hello-world/","title":"[置顶] Hello, World!"},{"content":"\r#\r关于我们\r#\r信息公开\r#\r服务器核心\r本服务器使用fabric作为服务器核心，并在此基础上使用mcdreforged守护服务器进程，实现插件挂载。\n#\r插件列表\r名称 维护者 功能 Beep Fallen_Breath, LucunJi @某人，@ all可作用于所有玩家。使用两个@@小心被打 DayCount NBT Alex3236 获取和输出服务器开服时间 Here Fallen_Breath, nathan21hz, Ra1ny_Yuki 显示坐标并高亮玩家 Location Marker Fallen_Breath, Van_Involution 一个服务端共享路标点管理器 Minecraft Data API Fallen_Breath 一个用获得玩家信息等数据的的 API Prime Backup Fallen_Breath 一个强大的MCDR备份插件，一套先进的Minecraft存档备份解决方案 Seen Pandaria, Fallen_Breath, Ra1ny_Yuki Show laziness rank easily Stats Helper Fallen_Breath 一个 Minecraft 统计信息助手 Task Pandaria, Fallen_Breath, Ra1ny_Yuki 用于展示进行中的工程任务的插件 #\rmod 列表\r名称 主要维护者 版本 Fabric API modmuss50 0.97.8 Fabric Carpet gnembon 1.4.141 Carpet TIS Addition Fallen-Breath 1.59 Lithium (for Fabric) 2No2Name 0.12.3 #\r加入我们\r","date":"2024-05-05T00:00:00Z","permalink":"https://5i-tomato.github.io/p/server-intro/","title":"Block Infinite Team 信息公开"},{"content":"\r#\r第 1 章 绪论\r#\r#\r第 2 章 数字系统\r#\r引言\r数字系统 定义如何使用独特符号来表示一个数字。\n如：${(2A)} _ {16}$ 和 ${(52)} _ {8}$ 都是表示相同的数量${(42)}_{10}$\n#\r位置化数字系统\r在位置化数字系统中，数字中符号所占据的位置决定了其表示的值。在该系统中。数字的表示如下： $$ \\pm {\\left ( S_{K-1}\\cdots S_2S_1S_0S_{-1}S_{-2}\\cdots S_{-L} \\right )} _b $$\n","date":"2024-04-27T00:00:00Z","permalink":"https://5i-tomato.github.io/p/cs-learning/","title":"CS 学习随笔"},{"content":"\r#\rGit操作速记\r什么是Git？\nGit 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 #\r1. 创建新仓库\r1 git init #\r2. 检出仓库\r1 2 git clone /path/to/repository git clone username@host:/path/to/repository #\r3. 工作流\r你的本地仓库由 git 维护的三棵“树”组成。\n第一个是你的 工作目录，它持有实际文件\n第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动\n最后是 HEAD，它指向你最后一次提交的结果\n#\r4. 添加和提交\r1 git add \u0026lt;filename\u0026gt; 1 git commit -m \u0026#34;[comment]\u0026#34; #\r5. 推送改动\r从HEAD推送到远端仓库，其中master可以替换成任何分支。\n1 git push origin master 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：\n1 git remote add origin \u0026lt;server\u0026gt; 如此你就能够将你的改动推送到所添加的服务器上去了。\n#\r6. 分支\r分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n创建一个叫做“feature_x”的分支，并切换过去：\n1 git checkout -b feature_x 切换回主分支：\n1 git checkout master 再把新建的分支删掉：\n1 git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：\n1 git push origin \u0026lt;branch\u0026gt; #\r7. 更新与合并\r要更新你的本地仓库至最新改动，执行：\n1 git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行：\n1 git merge \u0026lt;branch\u0026gt; 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：\n1 git add \u0026lt;filename\u0026gt; 在合并改动之前，你可以使用如下命令预览差异：\n1 `git diff \u0026lt;source_branch\u0026gt; \u0026lt;target_branch\u0026gt; #\r8.替换本地改动\r假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：\n1 git checkout -- \u0026lt;filename\u0026gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n1 2 git fetch origin git reset --hard origin/master ","date":"2024-04-18T00:00:00Z","image":"https://5i-tomato.github.io/p/git-learning/3_hu329c2b1d180f8a2a0671c8d0fe9f868d_69796_120x120_fill_box_smart1_3.png","permalink":"https://5i-tomato.github.io/p/git-learning/","title":"Git学习随笔"},{"content":"\r#\rC语言学习随笔\r#\r前言\r上大学后经历了一个学期，也是在疫情中度过，每天都是核酸、打卡…… 浑浑噩噩。一转眼过了一个学期，也习惯了大学的节奏，想着再学一学新东西，便选择了学习 C 语言。\n（哈哈，有 Java 基础还是快不少）\n#\r基础语法\r#\rHello, World!\rC语言是一种通用的编程语言，它与机器的工作方式密切相关。 理解计算机内存的工作方式是C语言编程的一个重要方面。 虽然C语言被认为 \u0026ldquo;难学\u0026rdquo;，实际上C语言是一种非常简单的语言，功能强大。\nC语言是一种非常常见的编程语言，它是许多应用程序的开发语言，如Windows、Python解释器、Git和许多其他编程语言。\nC语言是一种编译语言——这意味着为了运行它，编译器（例如GCC或Visual Studio）必须将编写的代码进行处理，然后创建一个可执行文件。这个文件可以被执行，会做我们想让程序做的事情。\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, World!\u0026#34;); return 0; } #\r变量和类型\r#\r数据类型\rC语言有很多种类型的变量，但只有几个基本类型。\n整数——可以是正数或负数的整数。使用char、int、short、long或long long来定义。 无符号整数——只能是正数的整数。使用unsigned char、unsigned int、unsigned short、unsigned long或unsigned long long定义。 浮点数——实数（带小数的数字）。使用float和double来定义。 结构——将在后面的结构部分解释。 不同类型的变量定义了它们的界限。一个char的范围只能从-128到127，而一个long的范围可以从-2,147,483,648到2,147,483,647（long和其他数字数据类型在不同的计算机上可能有另一个范围，例如——在64位计算机上从-9,223,372,036,854,775,808到9,223,372,036,854,775,807）。\n请注意，C语言没有布尔类型。通常情况下，它是用下面的符号定义的。\n1 2 3 #define BOOL char #define FALSE 0 #define TRUE 1 C语言使用字符数组来定义字符串，将在字符串部分进行解释。\n#\r定义变量\r通常使用int类型定义数字，它是一个字大小的整数，也就是程序的编译机器的默认数字大小。 在今天的大多数计算机上，它是一个32位的数字，这意味着数字的范围可以从-2,147,483,648到2,147,483,647。\n为了定义变量foo和bar，需要使用以下语法。\n1 2 int foo; int bar = 1; 变量foo可以使用，但由于没有初始化它，我们不知道里面有什么。变量bar装着数字1。\n现在，可以做一些数学运算。 假设a、b、c、d和e是变量，可以简单地使用加、减和乘法运算符 在下面的代码中，给a分配一个新值：\n1 2 3 int a = 0, b = 1, c = 2, d = 3, e = 4; a = b - c + d * e; printf(\u0026#34;%d\u0026#34;, a); /* will print 1-2+3*4 = 11 */ #\r示例\r创建一个程序，打印出数字a、b和c的和。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 3; float b = 4.5; double c = 5.25; float sum; sum = a + b + c; printf(\u0026#34;The sum of a, b, and c is %f.\u0026#34;, sum); return 0; #\r数组\r数组是一种特殊的变量，它可以在同一个变量名下容纳多个值，并以索引的形式组织起来。 数组的定义采用了非常简单的语法：\n1 2 /* 定义了一个由10个整数组成的数组 */ int numbers[10]; 从数组中访问一个数字也是用同样的语法完成的。 请注意，C语言中的数组是以零开头的，这意味着如果定义了一个大小为10的数组，那么数组单元0到9（包括）都被定义了。 numbers[10]不存在。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int numbers[10]; /* 填充该数组 */ numbers[0] = 10; numbers[1] = 20; numbers[2] = 30; numbers[3] = 40; numbers[4] = 50; numbers[5] = 60; numbers[6] = 70; /* 打印数组中的第7个数字，其索引为6 */ printf(\u0026#34;The 7th number in the array is %d\u0026#34;, numbers[6]); 数组只能有一种类型的变量，因为它们被实现为计算机内存中的一个数值序列。 正因如此，访问一个特定的数组单元是非常高效的。\n#\r示例\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main() { /* TODO：在这里定义成绩变量 */ int grades[3]; int average; grades[0] = 80; /* TODO：定义缺失的成绩，以使平均分达到85。 */ grades[1] = 85; grades[2] = 90; average = (grades[0] + grades[1] + grades[2]) / 3; printf(\u0026#34;The average of the 3 grades is: %d\u0026#34;, average); return 0; } #\r多维数组\rC语言可以创建和使用多维数组（类比 矩阵？）。下面是一个多维数组声明的一般形式。\n1 type name[size1][size2]...[sizeN]; 这里有一个基本示例参考——\n1 int foo[1][2][3]; 也可以这样——\n1 2 3 char vowels[1][5] = { {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;} }; #\r二维数组\r二维数组是最简单的多维数组。一个二维数组差不多是一个一维数组的列表。要声明一个大小为[x] [y]的二维整数数组，你可以这样写——\n1 type arrayName [x][y]; 其中type可以是C语言的任何数据类型（int, char, long, long long, double, 等等），arrayName是一个有效的C语言标识符，或变量。一个二维数组可以被认为是一个表，它有[ x ]行和[ y ]列。可以这样想象一个包含三行四列的二维数组a——\n像这样，数组a中的每个元素都由**a[i] [j]**形式的元素名来识别，其中\u0026rsquo;a\u0026rsquo;是数组的名称，\u0026lsquo;i\u0026rsquo;和\u0026rsquo;j\u0026rsquo;是独一无二的索引，合起来也就是\u0026rsquo;a\u0026rsquo;中的一个元素的意思。\n其实，不需要把[ x ]值真的放进去，因为如果这样做——\n1 2 3 4 char vowels[][5] = { {\u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;}, {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;} }; 编译器已经知道有两个 \u0026ldquo;维度\u0026rdquo;，但是，需要一个[ y ]值！! 编译器很聪明，但是它不会知道你在维度中使用了多少个整数、字符、浮点数，或者其他。请牢记这一点。\n#\r初始化二维数组\r多维数组中可以为每一行指定[]内的值。下面是一个3行4列的数组。为了方便，你可以不写3，不填写行数，它仍然可以工作。\n1 2 3 4 5 int a[3][4] = { {0, 1, 2, 3} , /* 初始化索引为0的行 */ {4, 5, 6, 7} , /* 初始化索引为1的行 */ {8, 9, 10, 11} /* 初始化索引为2的行 */ }; 里面的大括号表示想要的行，是可选的。下面的初始化效果与前面的例子相同——\n1 int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; #\r访问二维数组中的元素\r通过使用下标来访问二维数组中的元素，即使用数组的行索引和列索引。例如——\n1 int val = a[2][3]; 上述语句将从数组中取出第3行第4个元素。\n#\r示例\r尝试找出五名学生数学和物理两门学科的平均分。使用一个名为grades的二维数组去完成。数学对应的分数将被存储在第一行（grades[0]），物理对应的分数将被存储在第二行（grades[1]）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; int main() { int grades[2][5]; float average; int i; int j; grades[0][0] = 80; grades[0][1] = 70; grades[0][2] = 65; grades[0][3] = 89; grades[0][4] = 90; grades[1][0] = 85; grades[1][1] = 80; grades[1][2] = 80; grades[1][3] = 82; grades[1][4] = 87; for (i = 0; i \u0026lt; 2; i++) { average = 0; for (j = 0; j \u0026lt; 5; j++) { average += grades[i][j]; } average /= 5.0; printf(\u0026#34;The average marks obtained in subject %d is: %.2f\\n\u0026#34;, i, average); } return 0; } #\r条件语句\r#\r决策\r生活中我们必须做出决定。要根据自己的需要来做出决定，程序也是如此。\n下面是C语言中决策结构的一般形式。\n1 2 3 4 int target = 10; if (target == 10) { printf(\u0026#34;Target is equal to 10\u0026#34;); } #\rif语句\rif语句检查一个表达式是真还是假，并根据结果执行不同的代码。\n使用了==运算符判断两个变量是否相等，就像上面的例子一样。\n也可以用不等式运算符来判断。例如——\n1 2 3 4 5 6 7 8 9 10 int foo = 1; int bar = 2; if (foo \u0026lt; bar) { printf(\u0026#34;foo is smaller than bar.\u0026#34;); } if (foo \u0026gt; bar) { printf(\u0026#34;foo is greater than bar.\u0026#34;); } 使用else关键字在表达式为false时退出代码。\n1 2 3 4 5 6 7 8 int foo = 1; int bar = 2; if (foo \u0026lt; bar) { printf(\u0026#34;foo is smaller than bar.\u0026#34;); } else { printf(\u0026#34;foo is greater than bar.\u0026#34;); } 有两个以上的结果可供选择的情况下，可以将多个if else语句连锁。\n1 2 3 4 5 6 7 8 9 10 int foo = 1; int bar = 2; if (foo \u0026lt; bar) { printf(\u0026#34;foo is smaller than bar.\u0026#34;); } else if (foo == bar) { printf(\u0026#34;foo is equal to bar.\u0026#34;); } else { printf(\u0026#34;foo is greater than bar.\u0026#34;); } 也可以嵌套if else语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int peanuts_eaten = 22; int peanuts_in_jar = 100; int max_peanut_limit = 50; if (peanuts_in_jar \u0026gt; 80) { if (peanuts_eaten \u0026lt; max_peanut_limit) { printf(\u0026#34;Take as many peanuts as you want!\\n\u0026#34;); } } else { if (peanuts_eaten \u0026gt; peanuts_in_jar) { printf(\u0026#34;You can\u0026#39;t have anymore peanuts!\\n\u0026#34;); } else { printf(\u0026#34;Alright, just one more peanut.\\n\u0026#34;); } } 两个或多个表达式可以使用逻辑运算符检查是否都为真，或是否其中一个为真。使用AND运算符\u0026amp;\u0026amp;检查两个表达式是否都为真。使用OR运算符||检查是否至少有一个表达式为真。\n1 2 3 4 5 6 7 8 9 10 11 int foo = 1; int bar = 2; int moo = 3; if (foo \u0026lt; bar \u0026amp;\u0026amp; moo \u0026gt; bar) { printf(\u0026#34;foo is smaller than bar AND moo is larger than bar.\u0026#34;); } if (foo \u0026lt; bar || moo \u0026gt; bar) { printf(\u0026#34;foo is smaller than bar OR moo is larger than bar.\u0026#34;); } NOT运算符!类似：\n1 2 3 4 int target = 9; if (target != 10) { printf(\u0026#34;Target is not equal to 10\u0026#34;); } #\r示例\r在guessNumber函数中构建一个if语句，检查数字guess是否等于555。如果是，在该函数内用printf打印出 \u0026ldquo;正确。你猜对了！\u0026quot;。如果guess小于555，用printf打印出 \u0026ldquo;你猜的低了\u0026rdquo;。如果guess大于555，用printf打印出 \u0026ldquo;你猜的高了\u0026rdquo;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; void guessNumber(int guess) { // TODO：在这里写代码 if (guess \u0026lt; 555) { printf(\u0026#34;Your guess is too low.\\n\u0026#34;); } else if (guess \u0026gt; 555) { printf(\u0026#34;Your guess is too high.\\n\u0026#34;); } else { printf(\u0026#34;Correct. You guessed it!\\n\u0026#34;); } } int main() { guessNumber(500); guessNumber(600); guessNumber(555); } #\r字符串\r#\r字符串的定义\rC语言中的字符串实际上是字符数组。尽管使用指针是C语言中的高级课题，后面会详细解释，先使用指向字符数组的指针来定义简单的字符串，方法如下：\n1 char * name = \u0026#34;John Smith\u0026#34;; 这个方法创建了一个只能读取的字符串。 如果希望定义一个可以被操作的字符串，需要定义为一个字符数组。\n1 char name[] = \u0026#34;John Smith\u0026#34;; 符号不同是因为它分配了一个数组变量，所以可以对它进行操作。方括号[]告诉编译器自动计算数组的大小。实际上是否指明大小都是一样的，字符串的长度为字符数组的大小减一。\n1 2 3 char name[] = \u0026#34;John Smith\u0026#34;; /* 与下面的意思相同 */ char name[11] = \u0026#34;John Smith\u0026#34;; 尽管字符串John Smith正好是10个字符长，但需要加一，是为了表明字符串的结束。一个特殊的char（等于0）表示字符串的结束。字符串的结尾被标记出来是因为程序不知道字符串的长度——只有编译器根据代码才知道。\n#\r用printf格式化字符串\r可以使用printf方法将一个字符串与其他字符串一起格式化，具体方法如下：\n1 2 3 4 5 char * name = \u0026#34;John Smith\u0026#34;; int age = 27; /* 打印\u0026#39;John Smith is 27 years old.\u0026#39; */ printf(\u0026#34;%s is %d years old.\\n\u0026#34;, name, age); 请注意，在打印字符串时，必须添加一个换行符（\\n）来让下一个printf语句打印在一个新行中。\n#\r字符串长度\r函数strlen返回作为参数传递的字符串的长度。\n1 2 char * name = \u0026#34;Nikhil\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;,strlen(name)); #\r比较字符串\r函数strncmp对两个字符串进行比较。如果相同，返回数字0；如果不同，返回其他数字。 参数是要比较的两个字符串，以及最大比较长度。这个函数还有一个不安全的版本，叫做strcmp，不建议使用。例如：\n1 2 3 4 5 6 7 char * name = \u0026#34;John\u0026#34;; if (strncmp(name, \u0026#34;John\u0026#34;, 4) == 0) { printf(\u0026#34;Hello, John!\\n\u0026#34;); } else { printf(\u0026#34;You are not John. Go away.\\n\u0026#34;); } #\r字符串拼接\r函数strncat将src字符串的前n个字符添加到目标字符串中，其中n为min(n,length(src))。 传递的参数是目标字符串、源字符串和n——要增添的最大字符数。例如：\n1 2 3 4 5 6 char dest[20]=\u0026#34;Hello\u0026#34;; char src[20]=\u0026#34;World\u0026#34;; strncat(dest,src,3); printf(\u0026#34;%s\\n\u0026#34;,dest); strncat(dest,src,20); printf(\u0026#34;%s\\n\u0026#34;,dest); #\r示例\r使用指针定义字符串first_name，其值为John，使用字符数组定义字符串last_name，其值为Doe。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char * first_name = \u0026#34;John\u0026#34;; char last_name[] = \u0026#34;Doe\u0026#34;; char name[100]; last_name[0] = \u0026#39;B\u0026#39;; sprintf(name, \u0026#34;%s %s\u0026#34;, first_name, last_name); if (strncmp(name, \u0026#34;John Boe\u0026#34;, 100) == 0) { printf(\u0026#34;Done!\\n\u0026#34;); } name[0]=\u0026#39;\\0\u0026#39;; strncat(name,first_name,4); strncat(name,last_name,20); printf(\u0026#34;%s\\n\u0026#34;,name); return 0; } ","date":"2023-04-19T00:00:00Z","image":"https://5i-tomato.github.io/p/c-learning/c_huec6f21a985923607ae7803750dea9950_70493_120x120_fill_box_smart1_3.png","permalink":"https://5i-tomato.github.io/p/c-learning/","title":"C语言学习随笔"},{"content":"\r#\rMinecraft教程\rStatement：\n请支持正版！！！\n请注意分辨，本人不承担任何因个人操作造成的损失\n本教程是由玩家 Tomato295 编写的，如有疑问\n请移步至邮箱咨询：160783295@qq.com\n#\r一、选择启动器\r目前国内的主流启动器有：\nMInecraft Launcher（官方启动器，因为其谜一般的下载速度以及功能性，不推荐）\nHello Minecraft! Launcher（老牌第三方启动器，稳定）\nPlain Craft Launcher 2 （近年来的新兴启动器，功能丰富）\nBakaXL（二刺猿浓度较高的启动器，并且使用体验不错）\n其他启动器（优秀的启动器还有很多，请自行发掘）\n#\r二、选择登录方式\rMicrosoft登录（使用微软账号登录，由于Mojang官方的账号迁移，现已经成为绝大部分正版玩家的登录方式）\nMojang登录（使用Mojang账号登录，由于账号迁移政策，现已逐渐退出历史）\n第三方外置登录（使用第三方皮肤站，如Littleskin的验证服务器进行登录验证，属于非正版）\n下面是第三方登录的图解教程（LittleSkin与PCL2启动器为例）：\n离线模式（不过多介绍）\n请支持正版！！！\n#\r三、游戏下载\r在此我以Plain Craft Launcher 2 启动器为例。\n操作方式如下图：\n在此我介绍一下这些附加安装：\nOPtifine又叫高清修复，是很多光影的前置，同时也能实现性能优化。但不兼容Fabric，无法同时安装\nForge是MInecraft的主流API目前有50%的mod都在使用Forge\nFabric是一个用于Minecraft1.14+ 的轻量Mod API\nFabric API 必须与Fabric同时安装\nOptifabric 是 Optifine 的 Fabric 版本\nLiteLoader 已过时\n选择好附属安装后等待安装完成即可开始游戏。\n#\r四、其他安装\r#\rMod安装\r值得一提的是，目前Plain Craft Launcher 2、BakaXL 和Hello Minecraft! Launcher 等第三方启动器均支持启动器内Mod下载，为玩家提供了极大的便利。你也可以在互联网上下载mod文件。（mod的命名一般为 .jar ）\nMod下载完毕后，请放置在你游戏文件夹的 mods 文件夹下。\n注意：\nMod需下载你所安装游戏的对应版本，如1.12.2 的 Forge 版，1.16.5 的 Fabric 版。下载不对应的版本可能会导致游戏出现错误。 Mod的安装不是实时更新的，安装完毕后请重启游戏。 部分mod会依赖于前置mod，需一起下载。 部分mod之前可能会有冲突。 #\r材质包安装\r材质包文件请自行在互联网上寻找，一般后缀名为.zip，无需解压，直接放在resourcepacks文件夹下即可在游戏中选择加载。\n与mod一样，材质包需要对应版本。\n#\r光影包安装\r光影包需安装Optifine或者Optifabric，也可安装IRIS Shader mod (Fabric) 后\n光影包文件请自行在互联网上寻找，一般后缀名为.zip，无需解压，直接放在shaderpacks文件夹下即可在游戏中的视频设置中选择加载。\n光影包一般没有版本限制，但有部分只支持OPtifine。\n#\r数据包安装\r数据包一般可以从网上下载等不同渠道获得。它应该是一个.zip文件或一个文件夹。\n有的.zip文件本身并不是一个数据包，需要解压后提取数据包文件夹。这种情况下，一般数据包来源会有安装流程介绍。 如果不确定，可以打开这个.zip文件，查看里面是否有data文件夹和pack.mcmeta文件。如果有的话这个.zip文件就是数据包本体，可以直接放进datapacks文件夹。 一个文件夹根目录中必须包含pack.mcmeta文件才可以被游戏读取并辨认为数据包。 以下是在单人游戏中安装数据包的方法：\n打开Minecraft。 选择你需要安装数据包的世界，点击“编辑”，然后点击“打开世界文件夹”。 打开其中名为datapacks的文件夹，并将数据包.zip文件或文件夹放入其中。 下次打开世界的时候这个数据包就会被加载，并且优先级最高。 #\r整合包安装\r整合包也可直接在启动器中下载安装，也可从互联网下载。\n标准的整合包为.zip格式可直接拖入第三方启动器进行下载安装。\n非标准的整合包可能为一个游戏的打包压缩包，需解压后运行\n#\r五、个性化\r更改皮肤\n到此为止，你可能想要摆脱 Steve 和 Alex 的默认皮肤，更改一个属于自己的、更有个性的皮肤。\n皮肤的存储文件命名一般是*.png，可以自行使用工具（如MCSkin 3D）绘制，或在互联网上下载。\n正版用户可以直接前往 Minecraft 官方网站 或者 官方启动器更改皮肤。\n第三方登录可以在所属皮肤站更改皮肤。\n更改披风\n不像皮肤，披风不能被自由定制。玩家只能通过一些活动或事件来获取特定的披风。如果玩家拥有任何披风，就可以选择一件来装备上。一部分客户端Mod可能会提供其自定义的披风，但这些披风对玩家自己或其他安装了相同客户端Mod的玩家以外通常是不可见的。\n更换方式与更改皮肤方式一致。\n目前最常见的披风主要有三个。\n#\r六、游玩教程\r未完待续\n","date":"2022-08-09T00:00:00Z","image":"https://5i-tomato.github.io/p/minecraft-tutorial/wallpaper_minecraft_bedrock_edition_2560x1440_hud51d38eb75b0af79b8d133f241dd8e16_3249053_120x120_fill_box_smart1_3.png","permalink":"https://5i-tomato.github.io/p/minecraft-tutorial/","title":"Minecraft 教程"},{"content":"\r#\rJava 学习随笔\r#\r前言\r（前言部分于2024.04.19补充）\n学习 Java 编程是最早是在第一波疫情期间在家上网课时，当时上网课没认真听，想着总不能一事无成，就打算学习一种编程语言，正好当时（包括现在）沉迷于Minecraft: Java Edition，就选择了 Java ，虽然没用上（bushi）。更重要的是认识了一位正好在学Java基础的前辈，就在她的指引下学习了浙大翁恺的课程《零基础学Java语言》\n#\r计算\r#\r计算机与编程语言\r#\r第一个Java程序\r#\r变量与计算\r#\r浮点数计算\r#\r判断\r#\r比较\r#\r判断\r#\r分支\r#\r判断语句常见错误\r#\r循环\r#\r循环\r#\r循环控制\r#\rfor 循环\r#\r循环控制\r#\r数组\r#\r数组\r#\r数组计算\r#\r二维数组\r#\r使用对象\r#\r字符类型\r#\r包裹类型\r#\r字符串\r#\r函数\r#\r函数定义与调用\r#\r函数参数与函数内的调用\r","date":"2020-05-23T00:00:00Z","image":"https://5i-tomato.github.io/p/java-learning/java_hu35742ed53d18d3411353ca31cfdfeed5_44336_120x120_fill_box_smart1_3.png","permalink":"https://5i-tomato.github.io/p/java-learning/","title":"JavaSE学习随笔"}]